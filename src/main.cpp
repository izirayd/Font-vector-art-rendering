// ============================================================================
// Mesh Shader Font Renderer - Main
// Win32 window + D3D12 initialization + render loop
// ============================================================================

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef NOMINMAX
#define NOMINMAX
#endif

#include <windows.h>
#include <d3d12.h>
#include <dxgi1_6.h>
#include <wrl/client.h>
#include <cstdint>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <vector>
#include <string>
#include <stdexcept>

#include "font_processor.h"

// Compiled shader bytecode (generated by DXC at build time)
#include "font_ms.h"
#include "font_ps.h"

using Microsoft::WRL::ComPtr;

// ---------------------------------------------------------------------------
// Configuration
// ---------------------------------------------------------------------------
static const wchar_t* WINDOW_TITLE = L"Mesh Shader Font Renderer";
static const int       WINDOW_W    = 1280;
static const int       WINDOW_H    = 720;
static const int       FRAME_COUNT = 2;
static const char*     RENDER_TEXT = "QWERTY18976BP";
static const char*     FONT_PATH  = "C:\\Windows\\Fonts\\arial.ttf";
static const float     FONT_SIZE  = 100.0f; // pixel height for glyph processing

// ---------------------------------------------------------------------------
// Utility
// ---------------------------------------------------------------------------
static void ThrowIfFailed(HRESULT hr, const char* msg = "D3D12 Error")
{
    if (FAILED(hr)) {
        char buf[256];
        sprintf_s(buf, "%s (HRESULT 0x%08X)", msg, (unsigned)hr);
        OutputDebugStringA(buf);
        OutputDebugStringA("\n");
        throw std::runtime_error(buf);
    }
}

// ---------------------------------------------------------------------------
// Orthographic projection (row-major, maps glyph coords to NDC)
// ---------------------------------------------------------------------------
struct float4x4 {
    float m[4][4];
};

static float4x4 orthoProjection(float left, float right, float bottom, float top,
                                 float nearZ, float farZ)
{
    float4x4 mat = {};
    mat.m[0][0] =  2.0f / (right - left);
    mat.m[1][1] =  2.0f / (top - bottom);
    mat.m[2][2] =  1.0f / (farZ - nearZ);
    mat.m[3][0] = -(right + left) / (right - left);
    mat.m[3][1] = -(top + bottom) / (top - bottom);
    mat.m[3][2] = -nearZ / (farZ - nearZ);
    mat.m[3][3] =  1.0f;
    return mat;
}

// ---------------------------------------------------------------------------
// Pipeline state stream for mesh shader PSO
// ---------------------------------------------------------------------------

// Aligned stream member helper
template<typename InnerType, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE Type>
struct alignas(void*) PSSSubobject {
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE pType = Type;
    InnerType                           pInner{};
    PSSSubobject() = default;
    PSSSubobject(const InnerType& val) : pInner(val) {}
};

using PSS_RootSig     = PSSSubobject<ID3D12RootSignature*,           D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_ROOT_SIGNATURE>;
using PSS_MS          = PSSSubobject<D3D12_SHADER_BYTECODE,          D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_MS>;
using PSS_PS          = PSSSubobject<D3D12_SHADER_BYTECODE,          D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_PS>;
using PSS_Rasterizer  = PSSSubobject<D3D12_RASTERIZER_DESC,          D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_RASTERIZER>;
using PSS_Blend       = PSSSubobject<D3D12_BLEND_DESC,               D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_BLEND>;
using PSS_DepthStencil= PSSSubobject<D3D12_DEPTH_STENCIL_DESC,      D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL>;
using PSS_RTFormats   = PSSSubobject<D3D12_RT_FORMAT_ARRAY,          D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_RENDER_TARGET_FORMATS>;
using PSS_SampleDesc  = PSSSubobject<DXGI_SAMPLE_DESC,               D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_DESC>;
using PSS_SampleMask  = PSSSubobject<UINT,                           D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_MASK>;

struct MeshShaderPSOStream {
    PSS_RootSig      RootSignature;
    PSS_MS           MS;
    PSS_PS           PS;
    PSS_Rasterizer   Rasterizer;
    PSS_Blend        Blend;
    PSS_DepthStencil DepthStencil;
    PSS_RTFormats    RTFormats;
    PSS_SampleDesc   SampleDesc;
    PSS_SampleMask   SampleMask;
};

// ---------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------

// Window
static HWND g_hwnd = nullptr;
static bool g_running = true;

// D3D12
static ComPtr<IDXGIFactory6>            g_factory;
static ComPtr<ID3D12Device2>            g_device;
static ComPtr<ID3D12CommandQueue>       g_cmdQueue;
static ComPtr<IDXGISwapChain3>          g_swapChain;
static ComPtr<ID3D12DescriptorHeap>     g_rtvHeap;
static ComPtr<ID3D12DescriptorHeap>     g_srvHeap;
static ComPtr<ID3D12Resource>           g_renderTargets[FRAME_COUNT];
static ComPtr<ID3D12CommandAllocator>   g_cmdAlloc[FRAME_COUNT];
static ComPtr<ID3D12GraphicsCommandList6> g_cmdList;
static ComPtr<ID3D12Fence>              g_fence;
static UINT64                           g_fenceValues[FRAME_COUNT] = {};
static HANDLE                           g_fenceEvent = nullptr;
static UINT                             g_frameIndex = 0;
static UINT                             g_rtvDescSize = 0;

// Pipeline
static ComPtr<ID3D12RootSignature>      g_rootSig;
static ComPtr<ID3D12PipelineState>      g_pso;

// GPU resources
static ComPtr<ID3D12Resource>           g_vertexBuf;
static ComPtr<ID3D12Resource>           g_indexBuf;
static ComPtr<ID3D12Resource>           g_primAttrBuf;
static ComPtr<ID3D12Resource>           g_glyphletBuf;
static ComPtr<ID3D12Resource>           g_textBuf;
static ComPtr<ID3D12Resource>           g_constantBuf;
static void*                            g_constantBufPtr = nullptr;
static UINT                             g_numCharacters  = 0;

// ---------------------------------------------------------------------------
// Helper: Create a committed buffer on DEFAULT heap and upload initial data
// ---------------------------------------------------------------------------
static ComPtr<ID3D12Resource> CreateStructuredBuffer(
    const void* data, UINT64 totalSize, UINT stride)
{
    // Create upload buffer
    D3D12_HEAP_PROPERTIES uploadHeap = {};
    uploadHeap.Type = D3D12_HEAP_TYPE_UPLOAD;

    D3D12_RESOURCE_DESC bufDesc = {};
    bufDesc.Dimension          = D3D12_RESOURCE_DIMENSION_BUFFER;
    bufDesc.Width              = totalSize;
    bufDesc.Height             = 1;
    bufDesc.DepthOrArraySize   = 1;
    bufDesc.MipLevels          = 1;
    bufDesc.SampleDesc.Count   = 1;
    bufDesc.Layout             = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

    D3D12_HEAP_PROPERTIES defaultHeap = {};
    defaultHeap.Type = D3D12_HEAP_TYPE_DEFAULT;

    ComPtr<ID3D12Resource> defaultBuf;
    ThrowIfFailed(g_device->CreateCommittedResource(
        &defaultHeap, D3D12_HEAP_FLAG_NONE,
        &bufDesc, D3D12_RESOURCE_STATE_COMMON,
        nullptr, IID_PPV_ARGS(&defaultBuf)),
        "CreateCommittedResource (default)");

    ComPtr<ID3D12Resource> uploadBuf;
    ThrowIfFailed(g_device->CreateCommittedResource(
        &uploadHeap, D3D12_HEAP_FLAG_NONE,
        &bufDesc, D3D12_RESOURCE_STATE_GENERIC_READ,
        nullptr, IID_PPV_ARGS(&uploadBuf)),
        "CreateCommittedResource (upload)");

    // Copy data to upload buffer
    void* mapped = nullptr;
    uploadBuf->Map(0, nullptr, &mapped);
    memcpy(mapped, data, (size_t)totalSize);
    uploadBuf->Unmap(0, nullptr);

    // Record copy command
    ThrowIfFailed(g_cmdAlloc[0]->Reset(), "Reset cmdAlloc");
    ThrowIfFailed(g_cmdList->Reset(g_cmdAlloc[0].Get(), nullptr), "Reset cmdList");

    g_cmdList->CopyBufferRegion(defaultBuf.Get(), 0, uploadBuf.Get(), 0, totalSize);

    // Transition to SRV-readable
    D3D12_RESOURCE_BARRIER barrier = {};
    barrier.Type                   = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
    barrier.Transition.pResource   = defaultBuf.Get();
    barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_COPY_DEST;
    barrier.Transition.StateAfter  = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE | D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE;
    barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
    g_cmdList->ResourceBarrier(1, &barrier);

    ThrowIfFailed(g_cmdList->Close(), "Close cmdList");
    ID3D12CommandList* lists[] = { g_cmdList.Get() };
    g_cmdQueue->ExecuteCommandLists(1, lists);

    // Wait for GPU
    UINT64 fv = ++g_fenceValues[0];
    g_cmdQueue->Signal(g_fence.Get(), fv);
    if (g_fence->GetCompletedValue() < fv) {
        g_fence->SetEventOnCompletion(fv, g_fenceEvent);
        WaitForSingleObject(g_fenceEvent, INFINITE);
    }

    return defaultBuf;
}

// ---------------------------------------------------------------------------
// D3D12 Initialization
// ---------------------------------------------------------------------------
static void InitD3D12()
{
    // Enable debug layer in debug builds
#ifdef _DEBUG
    {
        ComPtr<ID3D12Debug> debug;
        if (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(&debug)))) {
            debug->EnableDebugLayer();
        }
    }
#endif

    // Factory
    UINT factoryFlags = 0;
#ifdef _DEBUG
    factoryFlags = DXGI_CREATE_FACTORY_DEBUG;
#endif
    ThrowIfFailed(CreateDXGIFactory2(factoryFlags, IID_PPV_ARGS(&g_factory)),
                  "CreateDXGIFactory2");

    // Adapter (prefer high-performance)
    ComPtr<IDXGIAdapter1> adapter;
    for (UINT i = 0;
         g_factory->EnumAdapterByGpuPreference(i, DXGI_GPU_PREFERENCE_HIGH_PERFORMANCE,
                                                IID_PPV_ARGS(&adapter)) != DXGI_ERROR_NOT_FOUND;
         ++i)
    {
        DXGI_ADAPTER_DESC1 desc;
        adapter->GetDesc1(&desc);
        if (desc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE) continue;

        if (SUCCEEDED(D3D12CreateDevice(adapter.Get(), D3D_FEATURE_LEVEL_12_0,
                                        IID_PPV_ARGS(&g_device)))) {
            wchar_t buf[256];
            swprintf_s(buf, L"Using adapter: %s\n", desc.Description);
            OutputDebugStringW(buf);
            break;
        }
    }
    if (!g_device) {
        ThrowIfFailed(E_FAIL, "No suitable D3D12 device found");
    }

    // Check mesh shader support
    D3D12_FEATURE_DATA_D3D12_OPTIONS7 opts7 = {};
    ThrowIfFailed(g_device->CheckFeatureSupport(
        D3D12_FEATURE_D3D12_OPTIONS7, &opts7, sizeof(opts7)),
        "CheckFeatureSupport OPTIONS7");

    if (opts7.MeshShaderTier == D3D12_MESH_SHADER_TIER_NOT_SUPPORTED) {
        MessageBoxA(nullptr, "Mesh shaders are not supported on this GPU.\n"
                    "Requires NVIDIA Turing (RTX 20xx+) or AMD RDNA2 (RX 6000+).",
                    "Error", MB_OK | MB_ICONERROR);
        ExitProcess(1);
    }

    // Command queue
    D3D12_COMMAND_QUEUE_DESC queueDesc = {};
    queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
    ThrowIfFailed(g_device->CreateCommandQueue(&queueDesc, IID_PPV_ARGS(&g_cmdQueue)),
                  "CreateCommandQueue");

    // Swap chain
    DXGI_SWAP_CHAIN_DESC1 scDesc = {};
    scDesc.Width       = WINDOW_W;
    scDesc.Height      = WINDOW_H;
    scDesc.Format      = DXGI_FORMAT_R8G8B8A8_UNORM;
    scDesc.SampleDesc  = {1, 0};
    scDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    scDesc.BufferCount = FRAME_COUNT;
    scDesc.SwapEffect  = DXGI_SWAP_EFFECT_FLIP_DISCARD;

    ComPtr<IDXGISwapChain1> sc1;
    ThrowIfFailed(g_factory->CreateSwapChainForHwnd(
        g_cmdQueue.Get(), g_hwnd, &scDesc, nullptr, nullptr, &sc1),
        "CreateSwapChainForHwnd");
    ThrowIfFailed(sc1.As(&g_swapChain), "QueryInterface SwapChain3");
    g_frameIndex = g_swapChain->GetCurrentBackBufferIndex();

    // Disable Alt+Enter fullscreen
    g_factory->MakeWindowAssociation(g_hwnd, DXGI_MWA_NO_ALT_ENTER);

    // RTV descriptor heap
    D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc = {};
    rtvHeapDesc.NumDescriptors = FRAME_COUNT;
    rtvHeapDesc.Type           = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
    ThrowIfFailed(g_device->CreateDescriptorHeap(&rtvHeapDesc, IID_PPV_ARGS(&g_rtvHeap)),
                  "CreateDescriptorHeap RTV");
    g_rtvDescSize = g_device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);

    // Create RTVs
    D3D12_CPU_DESCRIPTOR_HANDLE rtvHandle = g_rtvHeap->GetCPUDescriptorHandleForHeapStart();
    for (UINT i = 0; i < FRAME_COUNT; ++i) {
        ThrowIfFailed(g_swapChain->GetBuffer(i, IID_PPV_ARGS(&g_renderTargets[i])),
                      "GetBuffer");
        g_device->CreateRenderTargetView(g_renderTargets[i].Get(), nullptr, rtvHandle);
        rtvHandle.ptr += g_rtvDescSize;
    }

    // SRV descriptor heap (shader-visible, for structured buffer SRVs)
    D3D12_DESCRIPTOR_HEAP_DESC srvHeapDesc = {};
    srvHeapDesc.NumDescriptors = 5; // vertex, index, primAttr, glyphlet, text
    srvHeapDesc.Type           = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
    srvHeapDesc.Flags          = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
    ThrowIfFailed(g_device->CreateDescriptorHeap(&srvHeapDesc, IID_PPV_ARGS(&g_srvHeap)),
                  "CreateDescriptorHeap SRV");

    // Command allocators
    for (UINT i = 0; i < FRAME_COUNT; ++i) {
        ThrowIfFailed(g_device->CreateCommandAllocator(
            D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&g_cmdAlloc[i])),
            "CreateCommandAllocator");
    }

    // Command list
    ThrowIfFailed(g_device->CreateCommandList(
        0, D3D12_COMMAND_LIST_TYPE_DIRECT,
        g_cmdAlloc[0].Get(), nullptr, IID_PPV_ARGS(&g_cmdList)),
        "CreateCommandList");
    ThrowIfFailed(g_cmdList->Close(), "Close cmdList initial");

    // Fence
    ThrowIfFailed(g_device->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&g_fence)),
                  "CreateFence");
    g_fenceEvent = CreateEventA(nullptr, FALSE, FALSE, nullptr);
}

// ---------------------------------------------------------------------------
// Root Signature + PSO
// ---------------------------------------------------------------------------
static void CreatePipelineState()
{
    // Root signature: 1 CBV (b0) + 5 SRVs via descriptor table
    D3D12_DESCRIPTOR_RANGE1 srvRange = {};
    srvRange.RangeType                         = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
    srvRange.NumDescriptors                    = 5;
    srvRange.BaseShaderRegister                = 0; // t0..t4
    srvRange.RegisterSpace                     = 0;
    srvRange.OffsetInDescriptorsFromTableStart = 0;

    D3D12_ROOT_PARAMETER1 params[2] = {};

    // param 0: CBV at b0 (inline constant buffer view)
    params[0].ParameterType             = D3D12_ROOT_PARAMETER_TYPE_CBV;
    params[0].Descriptor.ShaderRegister = 0;
    params[0].Descriptor.RegisterSpace  = 0;
    params[0].ShaderVisibility          = D3D12_SHADER_VISIBILITY_ALL;

    // param 1: descriptor table with 5 SRVs
    params[1].ParameterType                       = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
    params[1].DescriptorTable.NumDescriptorRanges = 1;
    params[1].DescriptorTable.pDescriptorRanges   = &srvRange;
    params[1].ShaderVisibility                    = D3D12_SHADER_VISIBILITY_ALL;

    D3D12_VERSIONED_ROOT_SIGNATURE_DESC rsDesc = {};
    rsDesc.Version                = D3D_ROOT_SIGNATURE_VERSION_1_1;
    rsDesc.Desc_1_1.NumParameters = 2;
    rsDesc.Desc_1_1.pParameters   = params;
    rsDesc.Desc_1_1.Flags         = D3D12_ROOT_SIGNATURE_FLAG_NONE;

    ComPtr<ID3DBlob> sigBlob, errBlob;
    HRESULT hr = D3D12SerializeVersionedRootSignature(&rsDesc, &sigBlob, &errBlob);
    if (FAILED(hr)) {
        if (errBlob) OutputDebugStringA((const char*)errBlob->GetBufferPointer());
        ThrowIfFailed(hr, "D3D12SerializeVersionedRootSignature");
    }

    ThrowIfFailed(g_device->CreateRootSignature(
        0, sigBlob->GetBufferPointer(), sigBlob->GetBufferSize(),
        IID_PPV_ARGS(&g_rootSig)),
        "CreateRootSignature");

    // Pipeline state object (mesh shader pipeline)
    MeshShaderPSOStream psoStream = {};

    psoStream.RootSignature.pInner = g_rootSig.Get();

    psoStream.MS.pInner = { g_MSMain, sizeof(g_MSMain) };
    psoStream.PS.pInner = { g_PSMain, sizeof(g_PSMain) };

    // Rasterizer
    D3D12_RASTERIZER_DESC raster = {};
    raster.FillMode              = D3D12_FILL_MODE_SOLID;
    raster.CullMode              = D3D12_CULL_MODE_NONE;
    raster.DepthClipEnable       = TRUE;
    psoStream.Rasterizer.pInner  = raster;

    // Blend (premultiplied alpha for anti-aliased curve edges)
    D3D12_BLEND_DESC blend = {};
    blend.RenderTarget[0].BlendEnable           = TRUE;
    blend.RenderTarget[0].SrcBlend              = D3D12_BLEND_ONE;            // premultiplied src
    blend.RenderTarget[0].DestBlend             = D3D12_BLEND_INV_SRC_ALPHA;
    blend.RenderTarget[0].BlendOp               = D3D12_BLEND_OP_ADD;
    blend.RenderTarget[0].SrcBlendAlpha         = D3D12_BLEND_ONE;
    blend.RenderTarget[0].DestBlendAlpha        = D3D12_BLEND_INV_SRC_ALPHA;
    blend.RenderTarget[0].BlendOpAlpha          = D3D12_BLEND_OP_ADD;
    blend.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;
    psoStream.Blend.pInner = blend;

    // Depth stencil (disabled)
    D3D12_DEPTH_STENCIL_DESC ds = {};
    ds.DepthEnable   = FALSE;
    ds.StencilEnable = FALSE;
    psoStream.DepthStencil.pInner = ds;

    // Render target format
    D3D12_RT_FORMAT_ARRAY rtFormats = {};
    rtFormats.NumRenderTargets = 1;
    rtFormats.RTFormats[0]     = DXGI_FORMAT_R8G8B8A8_UNORM;
    psoStream.RTFormats.pInner = rtFormats;

    // Sample desc
    DXGI_SAMPLE_DESC sampleDesc = {1, 0};
    psoStream.SampleDesc.pInner = sampleDesc;

    psoStream.SampleMask.pInner = UINT_MAX;

    D3D12_PIPELINE_STATE_STREAM_DESC streamDesc = {};
    streamDesc.SizeInBytes                  = sizeof(psoStream);
    streamDesc.pPipelineStateSubobjectStream = &psoStream;

    ThrowIfFailed(g_device->CreatePipelineState(&streamDesc, IID_PPV_ARGS(&g_pso)),
                  "CreatePipelineState (mesh shader)");
}

// ---------------------------------------------------------------------------
// Create SRV for a structured buffer at a specific descriptor heap slot
// ---------------------------------------------------------------------------
static void CreateSRV(ID3D12Resource* resource, UINT numElements, UINT stride, UINT slot)
{
    D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
    srvDesc.Format                     = DXGI_FORMAT_UNKNOWN;
    srvDesc.ViewDimension              = D3D12_SRV_DIMENSION_BUFFER;
    srvDesc.Shader4ComponentMapping    = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
    srvDesc.Buffer.NumElements         = numElements;
    srvDesc.Buffer.StructureByteStride = stride;

    UINT descSize = g_device->GetDescriptorHandleIncrementSize(
                        D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
    D3D12_CPU_DESCRIPTOR_HANDLE handle = g_srvHeap->GetCPUDescriptorHandleForHeapStart();
    handle.ptr += slot * descSize;

    g_device->CreateShaderResourceView(resource, &srvDesc, handle);
}

// ---------------------------------------------------------------------------
// Upload font data to GPU
// ---------------------------------------------------------------------------
static void UploadFontData(FontProcessor& fontProc)
{
    // Build GPU data for the characters we need
    FontGPUData gpuData = fontProc.buildGPUData(RENDER_TEXT);

    // Ensure we have data
    if (gpuData.allVertices.empty()) {
        MessageBoxA(nullptr, "No glyph data generated. Check font file.", "Error", MB_OK);
        ExitProcess(1);
    }

    // Create structured buffers
    // t0: vertex buffer (float2 = 8 bytes per element)
    UINT64 vbSize = gpuData.allVertices.size() * sizeof(std::array<float,2>);
    g_vertexBuf = CreateStructuredBuffer(gpuData.allVertices.data(), vbSize, sizeof(float)*2);

    // t1: index buffer (uint3 = 12 bytes per element)
    UINT64 ibSize = gpuData.allTriangles.size() * sizeof(std::array<uint32_t,3>);
    g_indexBuf = CreateStructuredBuffer(gpuData.allTriangles.data(), ibSize, sizeof(uint32_t)*3);

    // t2: per-primitive attribute buffer (uint = 4 bytes)
    UINT64 paSize = gpuData.allPrimAttrs.size() * sizeof(uint32_t);
    g_primAttrBuf = CreateStructuredBuffer(gpuData.allPrimAttrs.data(), paSize, sizeof(uint32_t));

    // t3: glyphlet info buffer (GlyphletInfo = 16 bytes, 256 entries)
    UINT64 giSize = gpuData.glyphletInfos.size() * sizeof(GlyphletInfo);
    g_glyphletBuf = CreateStructuredBuffer(gpuData.glyphletInfos.data(), giSize, sizeof(GlyphletInfo));

    // t4: text buffer (CharacterRenderInfo = 16 bytes)
    auto textLayout = fontProc.layoutString(RENDER_TEXT, 0.0f, 0.0f);
    g_numCharacters = (UINT)textLayout.size();
    UINT64 tbSize = textLayout.size() * sizeof(CharacterRenderInfo);
    g_textBuf = CreateStructuredBuffer(textLayout.data(), tbSize, sizeof(CharacterRenderInfo));

    // Create SRVs
    CreateSRV(g_vertexBuf.Get(),   (UINT)gpuData.allVertices.size(),      sizeof(float)*2,         0);
    CreateSRV(g_indexBuf.Get(),    (UINT)gpuData.allTriangles.size(),     sizeof(uint32_t)*3,      1);
    CreateSRV(g_primAttrBuf.Get(), (UINT)gpuData.allPrimAttrs.size(),    sizeof(uint32_t),        2);
    CreateSRV(g_glyphletBuf.Get(), (UINT)gpuData.glyphletInfos.size(),   sizeof(GlyphletInfo),    3);
    CreateSRV(g_textBuf.Get(),     (UINT)textLayout.size(),              sizeof(CharacterRenderInfo), 4);

    // Constant buffer (upload heap, persistently mapped)
    D3D12_HEAP_PROPERTIES uploadHeap = {};
    uploadHeap.Type = D3D12_HEAP_TYPE_UPLOAD;

    D3D12_RESOURCE_DESC cbDesc = {};
    cbDesc.Dimension        = D3D12_RESOURCE_DIMENSION_BUFFER;
    cbDesc.Width            = 256; // 256-byte aligned
    cbDesc.Height           = 1;
    cbDesc.DepthOrArraySize = 1;
    cbDesc.MipLevels        = 1;
    cbDesc.SampleDesc.Count = 1;
    cbDesc.Layout           = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

    ThrowIfFailed(g_device->CreateCommittedResource(
        &uploadHeap, D3D12_HEAP_FLAG_NONE,
        &cbDesc, D3D12_RESOURCE_STATE_GENERIC_READ,
        nullptr, IID_PPV_ARGS(&g_constantBuf)),
        "CreateCommittedResource (CB)");

    g_constantBuf->Map(0, nullptr, &g_constantBufPtr);

    // Compute the bounding box of the text to set up ortho projection
    float minX =  1e30f, maxX = -1e30f;
    float minY =  1e30f, maxY = -1e30f;
    for (auto& ci : textLayout) {
        // Find glyphlet bounds
        int cp = (int)ci.character;
        auto gl = fontProc.processGlyph(cp);
        for (auto& v : gl.vertices) {
            float wx = v[0] + ci.posX;
            float wy = v[1] + ci.posY;
            if (wx < minX) minX = wx;
            if (wx > maxX) maxX = wx;
            if (wy < minY) minY = wy;
            if (wy > maxY) maxY = wy;
        }
    }

    // Add some padding
    float padX = (maxX - minX) * 0.05f;
    float padY = (maxY - minY) * 0.15f;


    float4x4 proj = orthoProjection(minX - padX, maxX + padX,
                                     minY - padY, maxY + padY,
                                     -1.0f, 1.0f);
    memcpy(g_constantBufPtr, &proj, sizeof(proj));
}

// ---------------------------------------------------------------------------
// Wait for GPU to finish current frame
// ---------------------------------------------------------------------------
static void WaitForFrame()
{
    UINT64 fv = ++g_fenceValues[g_frameIndex];
    g_cmdQueue->Signal(g_fence.Get(), fv);
    if (g_fence->GetCompletedValue() < fv) {
        g_fence->SetEventOnCompletion(fv, g_fenceEvent);
        WaitForSingleObject(g_fenceEvent, INFINITE);
    }
}

// ---------------------------------------------------------------------------
// Render one frame
// ---------------------------------------------------------------------------
static void RenderFrame()
{
    auto* alloc = g_cmdAlloc[g_frameIndex].Get();
    ThrowIfFailed(alloc->Reset(), "Reset alloc");
    ThrowIfFailed(g_cmdList->Reset(alloc, g_pso.Get()), "Reset cmdList");

    // Transition render target to RENDER_TARGET
    D3D12_RESOURCE_BARRIER barrier = {};
    barrier.Type                   = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
    barrier.Transition.pResource   = g_renderTargets[g_frameIndex].Get();
    barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_PRESENT;
    barrier.Transition.StateAfter  = D3D12_RESOURCE_STATE_RENDER_TARGET;
    barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
    g_cmdList->ResourceBarrier(1, &barrier);

    // Set render target
    D3D12_CPU_DESCRIPTOR_HANDLE rtvHandle = g_rtvHeap->GetCPUDescriptorHandleForHeapStart();
    rtvHandle.ptr += g_frameIndex * g_rtvDescSize;
    g_cmdList->OMSetRenderTargets(1, &rtvHandle, FALSE, nullptr);

    // Clear to dark background
    float clearColor[4] = { 0.1f, 0.1f, 0.15f, 1.0f };
    g_cmdList->ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);

    // Set viewport and scissor
    D3D12_VIEWPORT viewport = { 0, 0, (float)WINDOW_W, (float)WINDOW_H, 0.0f, 1.0f };
    D3D12_RECT scissor = { 0, 0, WINDOW_W, WINDOW_H };
    g_cmdList->RSSetViewports(1, &viewport);
    g_cmdList->RSSetScissorRects(1, &scissor);

    // Set root signature and descriptor heap
    g_cmdList->SetGraphicsRootSignature(g_rootSig.Get());
    ID3D12DescriptorHeap* heaps[] = { g_srvHeap.Get() };
    g_cmdList->SetDescriptorHeaps(1, heaps);

    // Root parameter 0: CBV (constant buffer)
    g_cmdList->SetGraphicsRootConstantBufferView(0, g_constantBuf->GetGPUVirtualAddress());

    // Root parameter 1: SRV descriptor table
    g_cmdList->SetGraphicsRootDescriptorTable(1, g_srvHeap->GetGPUDescriptorHandleForHeapStart());

    // Dispatch mesh shader: one thread group per character
    g_cmdList->DispatchMesh(g_numCharacters, 1, 1);

    // Transition render target to PRESENT
    barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
    barrier.Transition.StateAfter  = D3D12_RESOURCE_STATE_PRESENT;
    g_cmdList->ResourceBarrier(1, &barrier);

    ThrowIfFailed(g_cmdList->Close(), "Close cmdList");

    ID3D12CommandList* lists[] = { g_cmdList.Get() };
    g_cmdQueue->ExecuteCommandLists(1, lists);

    g_swapChain->Present(1, 0);

    WaitForFrame();
    g_frameIndex = g_swapChain->GetCurrentBackBufferIndex();
}

// ---------------------------------------------------------------------------
// Cleanup
// ---------------------------------------------------------------------------
static void Cleanup()
{
    // Wait for all frames
    for (UINT i = 0; i < FRAME_COUNT; ++i) {
        g_frameIndex = i;
        WaitForFrame();
    }
    if (g_fenceEvent) CloseHandle(g_fenceEvent);
    if (g_constantBufPtr) {
        g_constantBuf->Unmap(0, nullptr);
        g_constantBufPtr = nullptr;
    }
}

// ---------------------------------------------------------------------------
// Window procedure
// ---------------------------------------------------------------------------
static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    switch (msg) {
    case WM_DESTROY:
        g_running = false;
        PostQuitMessage(0);
        return 0;
    case WM_KEYDOWN:
        if (wp == VK_ESCAPE) {
            g_running = false;
            DestroyWindow(hwnd);
        }
        return 0;
    }
    return DefWindowProcW(hwnd, msg, wp, lp);
}

// ---------------------------------------------------------------------------
// Entry point
// ---------------------------------------------------------------------------
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow)
{
    // Register window class
    WNDCLASSEXW wc = {};
    wc.cbSize        = sizeof(wc);
    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc   = WndProc;
    wc.hInstance     = hInstance;
    wc.hCursor       = LoadCursorW(nullptr, (LPCWSTR)IDC_ARROW);
    wc.lpszClassName = L"MeshShaderFontWnd";
    RegisterClassExW(&wc);

    // Create window
    RECT r = { 0, 0, WINDOW_W, WINDOW_H };
    AdjustWindowRect(&r, WS_OVERLAPPEDWINDOW, FALSE);
    g_hwnd = CreateWindowExW(
        0, L"MeshShaderFontWnd", WINDOW_TITLE,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT,
        r.right - r.left, r.bottom - r.top,
        nullptr, nullptr, hInstance, nullptr);

    ShowWindow(g_hwnd, nCmdShow);
    UpdateWindow(g_hwnd);

    try {
        // Initialize D3D12
        InitD3D12();

        // Create pipeline state
        CreatePipelineState();

        // Load font and process glyphs
        FontProcessor fontProc;
        if (!fontProc.loadFont(FONT_PATH, FONT_SIZE)) {
            char errMsg[256];
            sprintf_s(errMsg, "Failed to load font: %s", FONT_PATH);
            MessageBoxA(nullptr, errMsg, "Error", MB_OK | MB_ICONERROR);
            return 1;
        }

        // Upload font data to GPU
        UploadFontData(fontProc);

        // Main loop
        MSG msg = {};
        while (g_running) {
            while (PeekMessageW(&msg, nullptr, 0, 0, PM_REMOVE)) {
                TranslateMessage(&msg);
                DispatchMessageW(&msg);
            }
            if (!g_running) break;

            RenderFrame();
        }

        Cleanup();
    }
    catch (const std::exception& e) {
        MessageBoxA(nullptr, e.what(), "Fatal Error", MB_OK | MB_ICONERROR);
        return 1;
    }

    return 0;
}
