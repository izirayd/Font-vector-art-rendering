// ============================================================================
// Mesh Shader Font Renderer - Main
// Win32 window + D3D12 initialization + render loop
// ============================================================================

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef NOMINMAX
#define NOMINMAX
#endif

#include <windows.h>
#include <windowsx.h>
#include <d3d12.h>
#include <dxgi1_6.h>
#include <wrl/client.h>
#include <cstdint>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cctype>
#include <algorithm>
#include <filesystem>
#include <utility>
#include <vector>
#include <string>
#include <stdexcept>

#include "font_processor.h"
#include "camera2d.h"

// Common Dialogs (Open File)
#include <commdlg.h>

// Dear ImGui
#include "imgui.h"
#include "backends/imgui_impl_win32.h"
#include "backends/imgui_impl_dx12.h"

// Win32 message handler forward declaration (intentionally not declared in imgui_impl_win32.h)
extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

// Compiled shader bytecode (generated by DXC at build time)
#include "font_ms.h"
#include "font_ps.h"

using Microsoft::WRL::ComPtr;

// ---------------------------------------------------------------------------
// Configuration
// ---------------------------------------------------------------------------
static const wchar_t* WINDOW_TITLE = L"Mesh Shader Font Renderer";
static const int       WINDOW_W    = 1280;
static const int       WINDOW_H    = 720;
static const int       FRAME_COUNT = 2;
static const char*     DEFAULT_RENDER_TEXT = "QWERTY18976BP";
static const char*     FONT_PATH  = "C:\\Windows\\Fonts\\arial.ttf";
static const wchar_t*  SYSTEM_FONTS_DIR = L"C:\\Windows\\Fonts";
static const float     FONT_SIZE  = 100.0f; // pixel height for glyph processing

// Runtime-editable text (via ImGui)
static std::string      g_renderText = DEFAULT_RENDER_TEXT;
static char             g_textInput[512] = "QWERTY18976BP";
static bool             g_requestTextRebuild = false;
static char             g_lastTextError[256] = {};

// Runtime-editable font (via ImGui)
struct FontChoice
{
    std::filesystem::path path;
    std::string           labelUtf8;   // filename
    std::string           fullPathUtf8;
};

static std::filesystem::path  g_fontPath = FONT_PATH;
static std::vector<FontChoice> g_systemFonts;
static int                    g_systemFontIndex = -1;
static char                   g_lastFontError[256] = {};

// ---------------------------------------------------------------------------
// Utility
// ---------------------------------------------------------------------------
static void ThrowIfFailed(HRESULT hr, const char* msg = "D3D12 Error")
{
    if (FAILED(hr)) {
        char buf[256];
        sprintf_s(buf, "%s (HRESULT 0x%08X)", msg, (unsigned)hr);
        OutputDebugStringA(buf);
        OutputDebugStringA("\n");
        throw std::runtime_error(buf);
    }
}

// ---------------------------------------------------------------------------
// Pipeline state stream for mesh shader PSO
// ---------------------------------------------------------------------------

// Aligned stream member helper
template<typename InnerType, D3D12_PIPELINE_STATE_SUBOBJECT_TYPE Type>
struct alignas(void*) PSSSubobject {
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE pType = Type;
    InnerType                           pInner{};
    PSSSubobject() = default;
    PSSSubobject(const InnerType& val) : pInner(val) {}
};

using PSS_RootSig     = PSSSubobject<ID3D12RootSignature*,           D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_ROOT_SIGNATURE>;
using PSS_MS          = PSSSubobject<D3D12_SHADER_BYTECODE,          D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_MS>;
using PSS_PS          = PSSSubobject<D3D12_SHADER_BYTECODE,          D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_PS>;
using PSS_Rasterizer  = PSSSubobject<D3D12_RASTERIZER_DESC,          D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_RASTERIZER>;
using PSS_Blend       = PSSSubobject<D3D12_BLEND_DESC,               D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_BLEND>;
using PSS_DepthStencil= PSSSubobject<D3D12_DEPTH_STENCIL_DESC,      D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL>;
using PSS_RTFormats   = PSSSubobject<D3D12_RT_FORMAT_ARRAY,          D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_RENDER_TARGET_FORMATS>;
using PSS_SampleDesc  = PSSSubobject<DXGI_SAMPLE_DESC,               D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_DESC>;
using PSS_SampleMask  = PSSSubobject<UINT,                           D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_MASK>;

struct MeshShaderPSOStream {
    PSS_RootSig      RootSignature;
    PSS_MS           MS;
    PSS_PS           PS;
    PSS_Rasterizer   Rasterizer;
    PSS_Blend        Blend;
    PSS_DepthStencil DepthStencil;
    PSS_RTFormats    RTFormats;
    PSS_SampleDesc   SampleDesc;
    PSS_SampleMask   SampleMask;
};

// ---------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------

// Window
static HWND g_hwnd = nullptr;
static bool g_running = true;
static bool g_isMinimized = false;

// Backbuffer / viewport size (in pixels)
static UINT g_backbufferW = WINDOW_W;
static UINT g_backbufferH = WINDOW_H;

// Resize requested from WM_SIZE, applied in the main loop.
static bool g_pendingResize = false;
static UINT g_pendingResizeW = 0;
static UINT g_pendingResizeH = 0;

// D3D12
static ComPtr<IDXGIFactory6>            g_factory;
static ComPtr<ID3D12Device2>            g_device;
static ComPtr<ID3D12CommandQueue>       g_cmdQueue;
static ComPtr<IDXGISwapChain3>          g_swapChain;
static ComPtr<ID3D12DescriptorHeap>     g_rtvHeap;
static ComPtr<ID3D12DescriptorHeap>     g_srvHeap;
static ComPtr<ID3D12DescriptorHeap>     g_imguiSrvHeap;
static ComPtr<ID3D12Resource>           g_renderTargets[FRAME_COUNT];
static ComPtr<ID3D12CommandAllocator>   g_cmdAlloc[FRAME_COUNT];
static ComPtr<ID3D12GraphicsCommandList6> g_cmdList;
static ComPtr<ID3D12Fence>              g_fence;
static UINT64                           g_fenceValue = 0; // monotonic fence value for all GPU work
static UINT64                           g_fenceValues[FRAME_COUNT] = {};
static HANDLE                           g_fenceEvent = nullptr;
static UINT                             g_frameIndex = 0;
static UINT                             g_rtvDescSize = 0;

// Pipeline
static ComPtr<ID3D12RootSignature>      g_rootSig;
static ComPtr<ID3D12PipelineState>      g_pso;

// GPU resources
static ComPtr<ID3D12Resource>           g_vertexBuf;
static ComPtr<ID3D12Resource>           g_indexBuf;
static ComPtr<ID3D12Resource>           g_primAttrBuf;
static ComPtr<ID3D12Resource>           g_glyphletBuf;
static ComPtr<ID3D12Resource>           g_textBuf;
static ComPtr<ID3D12Resource>           g_constantBuf;
static void*                            g_constantBufPtr = nullptr;
static UINT                             g_numCharacters  = 0;

static RectF                            g_baseView = { -1.0f, 1.0f, -1.0f, 1.0f };
static Camera2D                         g_camera;

static bool                             g_imguiInitialized = false;

static void GetClientSizePixels(HWND hwnd, UINT& outW, UINT& outH)
{
    RECT rc = {};
    GetClientRect(hwnd, &rc);
    outW = (rc.right > rc.left) ? (UINT)(rc.right - rc.left) : 0;
    outH = (rc.bottom > rc.top) ? (UINT)(rc.bottom - rc.top) : 0;
}

// ---------------------------------------------------------------------------
// Font selection helpers
// ---------------------------------------------------------------------------
static std::string ToLowerAscii(std::string s)
{
    for (char& ch : s) {
        ch = (char)std::tolower((unsigned char)ch);
    }
    return s;
}

static void SyncSystemFontIndexToCurrentPath()
{
    g_systemFontIndex = -1;
    for (int i = 0; i < (int)g_systemFonts.size(); ++i) {
        if (g_systemFonts[i].path == g_fontPath) {
            g_systemFontIndex = i;
            return;
        }
    }
}

static void RefreshSystemFontList()
{
    g_systemFonts.clear();

    namespace fs = std::filesystem;
    const fs::path fontDir = SYSTEM_FONTS_DIR;
    std::error_code ec;
    if (!fs::exists(fontDir, ec))
        return;

    for (const auto& entry : fs::directory_iterator(fontDir, ec)) {
        if (ec)
            break;

        if (!entry.is_regular_file(ec))
            continue;

        const fs::path p = entry.path();
        const std::string ext = ToLowerAscii(p.extension().u8string());
        if (ext != ".ttf" && ext != ".otf" && ext != ".ttc")
            continue;

        FontChoice fc;
        fc.path = p;
        fc.labelUtf8 = p.filename().u8string();
        fc.fullPathUtf8 = p.u8string();
        g_systemFonts.push_back(std::move(fc));
    }

    std::sort(g_systemFonts.begin(), g_systemFonts.end(),
              [](const FontChoice& a, const FontChoice& b) { return a.labelUtf8 < b.labelUtf8; });

    SyncSystemFontIndexToCurrentPath();
}

static bool OpenFontFileDialog(std::filesystem::path& outPath)
{
    wchar_t fileBuf[1024] = {};

    OPENFILENAMEW ofn = {};
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = g_hwnd;
    ofn.lpstrFilter =
        L"Font Files (*.ttf;*.otf;*.ttc)\0*.ttf;*.otf;*.ttc\0"
        L"All Files\0*.*\0";
    ofn.lpstrFile = fileBuf;
    ofn.nMaxFile = (DWORD)(sizeof(fileBuf) / sizeof(fileBuf[0]));
    ofn.lpstrInitialDir = SYSTEM_FONTS_DIR;
    ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_NOCHANGEDIR;
    ofn.lpstrDefExt = L"ttf";

    if (GetOpenFileNameW(&ofn) == TRUE) {
        outPath = fileBuf;
        return true;
    }
    return false;
}

// ---------------------------------------------------------------------------
// ImGui DX12 SRV descriptor allocator (required by ImGui 1.92+ DX12 backend)
// ---------------------------------------------------------------------------
struct ImGuiSrvDescriptorAllocator
{
    ID3D12DescriptorHeap* heap = nullptr;
    UINT descriptorSize = 0;
    UINT capacity = 0;
    UINT nextIndex = 0;
    std::vector<UINT> freeList;

    D3D12_CPU_DESCRIPTOR_HANDLE cpuStart = {};
    D3D12_GPU_DESCRIPTOR_HANDLE gpuStart = {};

    void Init(ID3D12DescriptorHeap* inHeap, UINT inCapacity, UINT inDescriptorSize)
    {
        heap = inHeap;
        descriptorSize = inDescriptorSize;
        capacity = inCapacity;
        nextIndex = 0;
        freeList.clear();
        cpuStart = heap->GetCPUDescriptorHandleForHeapStart();
        gpuStart = heap->GetGPUDescriptorHandleForHeapStart();
    }

    bool Alloc(D3D12_CPU_DESCRIPTOR_HANDLE* outCpu, D3D12_GPU_DESCRIPTOR_HANDLE* outGpu)
    {
        if (!heap || !outCpu || !outGpu)
            return false;

        UINT idx = 0;
        if (!freeList.empty()) {
            idx = freeList.back();
            freeList.pop_back();
        } else {
            if (nextIndex >= capacity)
                return false;
            idx = nextIndex++;
        }

        outCpu->ptr = cpuStart.ptr + (SIZE_T)idx * (SIZE_T)descriptorSize;
        outGpu->ptr = gpuStart.ptr + (UINT64)idx * (UINT64)descriptorSize;
        return true;
    }

    void Free(D3D12_CPU_DESCRIPTOR_HANDLE cpu, D3D12_GPU_DESCRIPTOR_HANDLE /*gpu*/)
    {
        if (!heap || cpu.ptr < cpuStart.ptr || descriptorSize == 0)
            return;
        UINT idx = (UINT)((cpu.ptr - cpuStart.ptr) / descriptorSize);
        if (idx < capacity)
            freeList.push_back(idx);
    }
};

static ImGuiSrvDescriptorAllocator        g_imguiSrvAlloc;

// ---------------------------------------------------------------------------
// Helper: Create a committed buffer on DEFAULT heap and upload initial data
// ---------------------------------------------------------------------------
static ComPtr<ID3D12Resource> CreateStructuredBuffer(
    const void* data, UINT64 totalSize, UINT stride)
{
    // Create upload buffer
    D3D12_HEAP_PROPERTIES uploadHeap = {};
    uploadHeap.Type = D3D12_HEAP_TYPE_UPLOAD;

    D3D12_RESOURCE_DESC bufDesc = {};
    bufDesc.Dimension          = D3D12_RESOURCE_DIMENSION_BUFFER;
    bufDesc.Width              = totalSize;
    bufDesc.Height             = 1;
    bufDesc.DepthOrArraySize   = 1;
    bufDesc.MipLevels          = 1;
    bufDesc.SampleDesc.Count   = 1;
    bufDesc.Layout             = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

    D3D12_HEAP_PROPERTIES defaultHeap = {};
    defaultHeap.Type = D3D12_HEAP_TYPE_DEFAULT;

    ComPtr<ID3D12Resource> defaultBuf;
    ThrowIfFailed(g_device->CreateCommittedResource(
        &defaultHeap, D3D12_HEAP_FLAG_NONE,
        &bufDesc, D3D12_RESOURCE_STATE_COMMON,
        nullptr, IID_PPV_ARGS(&defaultBuf)),
        "CreateCommittedResource (default)");

    ComPtr<ID3D12Resource> uploadBuf;
    ThrowIfFailed(g_device->CreateCommittedResource(
        &uploadHeap, D3D12_HEAP_FLAG_NONE,
        &bufDesc, D3D12_RESOURCE_STATE_GENERIC_READ,
        nullptr, IID_PPV_ARGS(&uploadBuf)),
        "CreateCommittedResource (upload)");

    // Copy data to upload buffer
    void* mapped = nullptr;
    uploadBuf->Map(0, nullptr, &mapped);
    memcpy(mapped, data, (size_t)totalSize);
    uploadBuf->Unmap(0, nullptr);

    // Record copy command
    ThrowIfFailed(g_cmdAlloc[0]->Reset(), "Reset cmdAlloc");
    ThrowIfFailed(g_cmdList->Reset(g_cmdAlloc[0].Get(), nullptr), "Reset cmdList");

    g_cmdList->CopyBufferRegion(defaultBuf.Get(), 0, uploadBuf.Get(), 0, totalSize);

    // Transition to SRV-readable
    D3D12_RESOURCE_BARRIER barrier = {};
    barrier.Type                   = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
    barrier.Transition.pResource   = defaultBuf.Get();
    barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_COPY_DEST;
    barrier.Transition.StateAfter  = D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE | D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE;
    barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
    g_cmdList->ResourceBarrier(1, &barrier);

    ThrowIfFailed(g_cmdList->Close(), "Close cmdList");
    ID3D12CommandList* lists[] = { g_cmdList.Get() };
    g_cmdQueue->ExecuteCommandLists(1, lists);

    // Wait for GPU
    const UINT64 fv = ++g_fenceValue;
    ThrowIfFailed(g_cmdQueue->Signal(g_fence.Get(), fv), "Signal fence (upload)");
    if (g_fence->GetCompletedValue() < fv) {
        ThrowIfFailed(g_fence->SetEventOnCompletion(fv, g_fenceEvent), "SetEventOnCompletion (upload)");
        WaitForSingleObject(g_fenceEvent, INFINITE);
    }

    return defaultBuf;
}

// ---------------------------------------------------------------------------
// D3D12 Initialization
// ---------------------------------------------------------------------------
static void InitD3D12()
{
    // Enable debug layer in debug builds
#ifdef _DEBUG
    {
        ComPtr<ID3D12Debug> debug;
        if (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(&debug)))) {
            debug->EnableDebugLayer();
        }
    }
#endif

    // Factory
    UINT factoryFlags = 0;
#ifdef _DEBUG
    factoryFlags = DXGI_CREATE_FACTORY_DEBUG;
#endif
    ThrowIfFailed(CreateDXGIFactory2(factoryFlags, IID_PPV_ARGS(&g_factory)),
                  "CreateDXGIFactory2");

    // Adapter (prefer high-performance)
    ComPtr<IDXGIAdapter1> adapter;
    for (UINT i = 0;
         g_factory->EnumAdapterByGpuPreference(i, DXGI_GPU_PREFERENCE_HIGH_PERFORMANCE,
                                                IID_PPV_ARGS(&adapter)) != DXGI_ERROR_NOT_FOUND;
         ++i)
    {
        DXGI_ADAPTER_DESC1 desc;
        adapter->GetDesc1(&desc);
        if (desc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE) continue;

        if (SUCCEEDED(D3D12CreateDevice(adapter.Get(), D3D_FEATURE_LEVEL_12_0,
                                        IID_PPV_ARGS(&g_device)))) {
            wchar_t buf[256];
            swprintf_s(buf, L"Using adapter: %s\n", desc.Description);
            OutputDebugStringW(buf);
            break;
        }
    }
    if (!g_device) {
        ThrowIfFailed(E_FAIL, "No suitable D3D12 device found");
    }

    // Check mesh shader support
    D3D12_FEATURE_DATA_D3D12_OPTIONS7 opts7 = {};
    ThrowIfFailed(g_device->CheckFeatureSupport(
        D3D12_FEATURE_D3D12_OPTIONS7, &opts7, sizeof(opts7)),
        "CheckFeatureSupport OPTIONS7");

    if (opts7.MeshShaderTier == D3D12_MESH_SHADER_TIER_NOT_SUPPORTED) {
        MessageBoxA(nullptr, "Mesh shaders are not supported on this GPU.\n"
                    "Requires NVIDIA Turing (RTX 20xx+) or AMD RDNA2 (RX 6000+).",
                    "Error", MB_OK | MB_ICONERROR);
        ExitProcess(1);
    }

    // Command queue
    D3D12_COMMAND_QUEUE_DESC queueDesc = {};
    queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
    ThrowIfFailed(g_device->CreateCommandQueue(&queueDesc, IID_PPV_ARGS(&g_cmdQueue)),
                  "CreateCommandQueue");

    // Swap chain
    UINT clientW = 0, clientH = 0;
    GetClientSizePixels(g_hwnd, clientW, clientH);
    if (clientW == 0) clientW = WINDOW_W;
    if (clientH == 0) clientH = WINDOW_H;
    g_backbufferW = clientW;
    g_backbufferH = clientH;

    DXGI_SWAP_CHAIN_DESC1 scDesc = {};
    scDesc.Width       = clientW;
    scDesc.Height      = clientH;
    scDesc.Format      = DXGI_FORMAT_R8G8B8A8_UNORM;
    scDesc.SampleDesc  = {1, 0};
    scDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    scDesc.BufferCount = FRAME_COUNT;
    scDesc.SwapEffect  = DXGI_SWAP_EFFECT_FLIP_DISCARD;

    ComPtr<IDXGISwapChain1> sc1;
    ThrowIfFailed(g_factory->CreateSwapChainForHwnd(
        g_cmdQueue.Get(), g_hwnd, &scDesc, nullptr, nullptr, &sc1),
        "CreateSwapChainForHwnd");
    ThrowIfFailed(sc1.As(&g_swapChain), "QueryInterface SwapChain3");
    g_frameIndex = g_swapChain->GetCurrentBackBufferIndex();

    // Disable Alt+Enter fullscreen
    g_factory->MakeWindowAssociation(g_hwnd, DXGI_MWA_NO_ALT_ENTER);

    // RTV descriptor heap
    D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc = {};
    rtvHeapDesc.NumDescriptors = FRAME_COUNT;
    rtvHeapDesc.Type           = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
    ThrowIfFailed(g_device->CreateDescriptorHeap(&rtvHeapDesc, IID_PPV_ARGS(&g_rtvHeap)),
                  "CreateDescriptorHeap RTV");
    g_rtvDescSize = g_device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);

    // Create RTVs
    D3D12_CPU_DESCRIPTOR_HANDLE rtvHandle = g_rtvHeap->GetCPUDescriptorHandleForHeapStart();
    for (UINT i = 0; i < FRAME_COUNT; ++i) {
        ThrowIfFailed(g_swapChain->GetBuffer(i, IID_PPV_ARGS(&g_renderTargets[i])),
                      "GetBuffer");
        g_device->CreateRenderTargetView(g_renderTargets[i].Get(), nullptr, rtvHandle);
        rtvHandle.ptr += g_rtvDescSize;
    }

    // SRV descriptor heap (shader-visible, for structured buffer SRVs)
    D3D12_DESCRIPTOR_HEAP_DESC srvHeapDesc = {};
    srvHeapDesc.NumDescriptors = 5; // vertex, index, primAttr, glyphlet, text
    srvHeapDesc.Type           = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
    srvHeapDesc.Flags          = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
    ThrowIfFailed(g_device->CreateDescriptorHeap(&srvHeapDesc, IID_PPV_ARGS(&g_srvHeap)),
                  "CreateDescriptorHeap SRV");

    // Command allocators
    for (UINT i = 0; i < FRAME_COUNT; ++i) {
        ThrowIfFailed(g_device->CreateCommandAllocator(
            D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&g_cmdAlloc[i])),
            "CreateCommandAllocator");
    }

    // Command list
    ThrowIfFailed(g_device->CreateCommandList(
        0, D3D12_COMMAND_LIST_TYPE_DIRECT,
        g_cmdAlloc[0].Get(), nullptr, IID_PPV_ARGS(&g_cmdList)),
        "CreateCommandList");
    ThrowIfFailed(g_cmdList->Close(), "Close cmdList initial");

    // Fence
    ThrowIfFailed(g_device->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&g_fence)),
                  "CreateFence");
    g_fenceEvent = CreateEventA(nullptr, FALSE, FALSE, nullptr);
}

// ---------------------------------------------------------------------------
// Dear ImGui initialization/shutdown
// ---------------------------------------------------------------------------
static void InitImGui()
{
    if (g_imguiInitialized) return;

    // SRV heap for ImGui (shader-visible)
    D3D12_DESCRIPTOR_HEAP_DESC srvHeapDesc = {};
    srvHeapDesc.NumDescriptors = 256;
    srvHeapDesc.Type           = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
    srvHeapDesc.Flags          = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
    ThrowIfFailed(g_device->CreateDescriptorHeap(&srvHeapDesc, IID_PPV_ARGS(&g_imguiSrvHeap)),
                  "CreateDescriptorHeap ImGui SRV");

    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGui::StyleColorsDark();

    ImGuiIO& io = ImGui::GetIO();
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
    io.IniFilename = nullptr;  // avoid creating imgui.ini on disk
    io.LogFilename = nullptr;

    if (!ImGui_ImplWin32_Init(g_hwnd)) {
        throw std::runtime_error("ImGui_ImplWin32_Init failed.");
    }

    const UINT descSize = g_device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
    g_imguiSrvAlloc.Init(g_imguiSrvHeap.Get(), srvHeapDesc.NumDescriptors, descSize);

    ImGui_ImplDX12_InitInfo initInfo;
    initInfo.Device = g_device.Get();
    initInfo.CommandQueue = g_cmdQueue.Get(); // IMPORTANT: must be the same queue used for rendering.
    initInfo.NumFramesInFlight = FRAME_COUNT;
    initInfo.RTVFormat = DXGI_FORMAT_R8G8B8A8_UNORM;
    initInfo.DSVFormat = DXGI_FORMAT_UNKNOWN;
    initInfo.SrvDescriptorHeap = g_imguiSrvHeap.Get();
    initInfo.UserData = &g_imguiSrvAlloc;
    initInfo.SrvDescriptorAllocFn = [](ImGui_ImplDX12_InitInfo* info, D3D12_CPU_DESCRIPTOR_HANDLE* out_cpu, D3D12_GPU_DESCRIPTOR_HANDLE* out_gpu)
    {
        auto* alloc = static_cast<ImGuiSrvDescriptorAllocator*>(info->UserData);
        if (!alloc->Alloc(out_cpu, out_gpu)) {
            out_cpu->ptr = 0;
            out_gpu->ptr = 0;
        }
    };
    initInfo.SrvDescriptorFreeFn = [](ImGui_ImplDX12_InitInfo* info, D3D12_CPU_DESCRIPTOR_HANDLE cpu, D3D12_GPU_DESCRIPTOR_HANDLE gpu)
    {
        auto* alloc = static_cast<ImGuiSrvDescriptorAllocator*>(info->UserData);
        alloc->Free(cpu, gpu);
    };

    if (!ImGui_ImplDX12_Init(&initInfo)) {
        throw std::runtime_error("ImGui_ImplDX12_Init failed.");
    }

    g_imguiInitialized = true;
}

static void ShutdownImGui()
{
    if (!g_imguiInitialized) return;

    ImGui_ImplDX12_Shutdown();
    ImGui_ImplWin32_Shutdown();
    ImGui::DestroyContext();

    g_imguiSrvHeap.Reset();
    g_imguiInitialized = false;
}

// ---------------------------------------------------------------------------
// Root Signature + PSO
// ---------------------------------------------------------------------------
static void CreatePipelineState()
{
    // Root signature: 1 CBV (b0) + 5 SRVs via descriptor table
    D3D12_DESCRIPTOR_RANGE1 srvRange = {};
    srvRange.RangeType                         = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
    srvRange.NumDescriptors                    = 5;
    srvRange.BaseShaderRegister                = 0; // t0..t4
    srvRange.RegisterSpace                     = 0;
    srvRange.OffsetInDescriptorsFromTableStart = 0;

    D3D12_ROOT_PARAMETER1 params[2] = {};

    // param 0: CBV at b0 (inline constant buffer view)
    params[0].ParameterType             = D3D12_ROOT_PARAMETER_TYPE_CBV;
    params[0].Descriptor.ShaderRegister = 0;
    params[0].Descriptor.RegisterSpace  = 0;
    params[0].ShaderVisibility          = D3D12_SHADER_VISIBILITY_ALL;

    // param 1: descriptor table with 5 SRVs
    params[1].ParameterType                       = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
    params[1].DescriptorTable.NumDescriptorRanges = 1;
    params[1].DescriptorTable.pDescriptorRanges   = &srvRange;
    params[1].ShaderVisibility                    = D3D12_SHADER_VISIBILITY_ALL;

    D3D12_VERSIONED_ROOT_SIGNATURE_DESC rsDesc = {};
    rsDesc.Version                = D3D_ROOT_SIGNATURE_VERSION_1_1;
    rsDesc.Desc_1_1.NumParameters = 2;
    rsDesc.Desc_1_1.pParameters   = params;
    rsDesc.Desc_1_1.Flags         = D3D12_ROOT_SIGNATURE_FLAG_NONE;

    ComPtr<ID3DBlob> sigBlob, errBlob;
    HRESULT hr = D3D12SerializeVersionedRootSignature(&rsDesc, &sigBlob, &errBlob);
    if (FAILED(hr)) {
        if (errBlob) OutputDebugStringA((const char*)errBlob->GetBufferPointer());
        ThrowIfFailed(hr, "D3D12SerializeVersionedRootSignature");
    }

    ThrowIfFailed(g_device->CreateRootSignature(
        0, sigBlob->GetBufferPointer(), sigBlob->GetBufferSize(),
        IID_PPV_ARGS(&g_rootSig)),
        "CreateRootSignature");

    // Pipeline state object (mesh shader pipeline)
    MeshShaderPSOStream psoStream = {};

    psoStream.RootSignature.pInner = g_rootSig.Get();

    psoStream.MS.pInner = { g_MSMain, sizeof(g_MSMain) };
    psoStream.PS.pInner = { g_PSMain, sizeof(g_PSMain) };

    // Rasterizer
    D3D12_RASTERIZER_DESC raster = {};
    raster.FillMode              = D3D12_FILL_MODE_SOLID;
    raster.CullMode              = D3D12_CULL_MODE_NONE;
    raster.DepthClipEnable       = TRUE;
    psoStream.Rasterizer.pInner  = raster;

    // Blend (premultiplied alpha for anti-aliased curve edges)
    D3D12_BLEND_DESC blend = {};
    blend.RenderTarget[0].BlendEnable           = TRUE;
    blend.RenderTarget[0].SrcBlend              = D3D12_BLEND_ONE;            // premultiplied src
    blend.RenderTarget[0].DestBlend             = D3D12_BLEND_INV_SRC_ALPHA;
    blend.RenderTarget[0].BlendOp               = D3D12_BLEND_OP_ADD;
    blend.RenderTarget[0].SrcBlendAlpha         = D3D12_BLEND_ONE;
    blend.RenderTarget[0].DestBlendAlpha        = D3D12_BLEND_INV_SRC_ALPHA;
    blend.RenderTarget[0].BlendOpAlpha          = D3D12_BLEND_OP_ADD;
    blend.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;
    psoStream.Blend.pInner = blend;

    // Depth stencil (disabled)
    D3D12_DEPTH_STENCIL_DESC ds = {};
    ds.DepthEnable   = FALSE;
    ds.StencilEnable = FALSE;
    psoStream.DepthStencil.pInner = ds;

    // Render target format
    D3D12_RT_FORMAT_ARRAY rtFormats = {};
    rtFormats.NumRenderTargets = 1;
    rtFormats.RTFormats[0]     = DXGI_FORMAT_R8G8B8A8_UNORM;
    psoStream.RTFormats.pInner = rtFormats;

    // Sample desc
    DXGI_SAMPLE_DESC sampleDesc = {1, 0};
    psoStream.SampleDesc.pInner = sampleDesc;

    psoStream.SampleMask.pInner = UINT_MAX;

    D3D12_PIPELINE_STATE_STREAM_DESC streamDesc = {};
    streamDesc.SizeInBytes                  = sizeof(psoStream);
    streamDesc.pPipelineStateSubobjectStream = &psoStream;

    ThrowIfFailed(g_device->CreatePipelineState(&streamDesc, IID_PPV_ARGS(&g_pso)),
                  "CreatePipelineState (mesh shader)");
}

// ---------------------------------------------------------------------------
// Create SRV for a structured buffer at a specific descriptor heap slot
// ---------------------------------------------------------------------------
static void CreateSRV(ID3D12Resource* resource, UINT numElements, UINT stride, UINT slot)
{
    D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
    srvDesc.Format                     = DXGI_FORMAT_UNKNOWN;
    srvDesc.ViewDimension              = D3D12_SRV_DIMENSION_BUFFER;
    srvDesc.Shader4ComponentMapping    = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
    srvDesc.Buffer.NumElements         = numElements;
    srvDesc.Buffer.StructureByteStride = stride;

    UINT descSize = g_device->GetDescriptorHandleIncrementSize(
                        D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
    D3D12_CPU_DESCRIPTOR_HANDLE handle = g_srvHeap->GetCPUDescriptorHandleForHeapStart();
    handle.ptr += slot * descSize;

    g_device->CreateShaderResourceView(resource, &srvDesc, handle);
}

// ---------------------------------------------------------------------------
// Constant buffer (transform matrix)
// ---------------------------------------------------------------------------
static void CreateConstantBuffer()
{
    if (g_constantBuf) return;

    // Upload heap, persistently mapped
    D3D12_HEAP_PROPERTIES uploadHeap = {};
    uploadHeap.Type = D3D12_HEAP_TYPE_UPLOAD;

    D3D12_RESOURCE_DESC cbDesc = {};
    cbDesc.Dimension        = D3D12_RESOURCE_DIMENSION_BUFFER;
    cbDesc.Width            = 256; // 256-byte aligned
    cbDesc.Height           = 1;
    cbDesc.DepthOrArraySize = 1;
    cbDesc.MipLevels        = 1;
    cbDesc.SampleDesc.Count = 1;
    cbDesc.Layout           = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

    ThrowIfFailed(g_device->CreateCommittedResource(
        &uploadHeap, D3D12_HEAP_FLAG_NONE,
        &cbDesc, D3D12_RESOURCE_STATE_GENERIC_READ,
        nullptr, IID_PPV_ARGS(&g_constantBuf)),
        "CreateCommittedResource (CB)");

    ThrowIfFailed(g_constantBuf->Map(0, nullptr, &g_constantBufPtr), "Map (CB)");
}

// ---------------------------------------------------------------------------
// Build/rebuild font GPU buffers for the given text
// ---------------------------------------------------------------------------
static bool RebuildTextResources(FontProcessor& fontProc, const std::string& text)
{
    g_lastTextError[0] = '\0';

    if (text.empty()) {
        strcpy_s(g_lastTextError, "Text is empty.");
        return false;
    }

    CreateConstantBuffer();

    // Build GPU data for the unique characters used by the string.
    FontGPUData gpuData = fontProc.buildGPUData(text);
    if (gpuData.allVertices.empty() || gpuData.allTriangles.empty()) {
        strcpy_s(g_lastTextError, "No glyph data generated for this text.");
        return false;
    }

    // Layout string into per-character positions.
    auto textLayout = fontProc.layoutString(text, 0.0f, 0.0f);
    if (textLayout.empty()) {
        strcpy_s(g_lastTextError, "Layout produced 0 characters.");
        return false;
    }

    // Create new buffers (only swap globals after all succeed).
    ComPtr<ID3D12Resource> vertexBuf;
    ComPtr<ID3D12Resource> indexBuf;
    ComPtr<ID3D12Resource> primAttrBuf;
    ComPtr<ID3D12Resource> glyphletBuf;
    ComPtr<ID3D12Resource> textBuf;

    // t0: vertex buffer (float2 = 8 bytes per element)
    UINT64 vbSize = gpuData.allVertices.size() * sizeof(std::array<float, 2>);
    vertexBuf = CreateStructuredBuffer(gpuData.allVertices.data(), vbSize, sizeof(float) * 2);

    // t1: index buffer (uint3 = 12 bytes per element)
    UINT64 ibSize = gpuData.allTriangles.size() * sizeof(std::array<uint32_t, 3>);
    indexBuf = CreateStructuredBuffer(gpuData.allTriangles.data(), ibSize, sizeof(uint32_t) * 3);

    // t2: per-primitive attribute buffer (uint = 4 bytes)
    UINT64 paSize = gpuData.allPrimAttrs.size() * sizeof(uint32_t);
    primAttrBuf = CreateStructuredBuffer(gpuData.allPrimAttrs.data(), paSize, sizeof(uint32_t));

    // t3: glyphlet info buffer (GlyphletInfo = 16 bytes, 256 entries)
    UINT64 giSize = gpuData.glyphletInfos.size() * sizeof(GlyphletInfo);
    glyphletBuf = CreateStructuredBuffer(gpuData.glyphletInfos.data(), giSize, sizeof(GlyphletInfo));

    // t4: text buffer (CharacterRenderInfo = 16 bytes)
    UINT64 tbSize = textLayout.size() * sizeof(CharacterRenderInfo);
    textBuf = CreateStructuredBuffer(textLayout.data(), tbSize, sizeof(CharacterRenderInfo));

    // Swap globals
    g_vertexBuf   = vertexBuf;
    g_indexBuf    = indexBuf;
    g_primAttrBuf = primAttrBuf;
    g_glyphletBuf = glyphletBuf;
    g_textBuf     = textBuf;
    g_numCharacters = (UINT)textLayout.size();

    // Create/refresh SRVs in our descriptor heap slots.
    CreateSRV(g_vertexBuf.Get(),   (UINT)gpuData.allVertices.size(),   sizeof(float) * 2,              0);
    CreateSRV(g_indexBuf.Get(),    (UINT)gpuData.allTriangles.size(),  sizeof(uint32_t) * 3,           1);
    CreateSRV(g_primAttrBuf.Get(), (UINT)gpuData.allPrimAttrs.size(),  sizeof(uint32_t),               2);
    CreateSRV(g_glyphletBuf.Get(), (UINT)gpuData.glyphletInfos.size(), sizeof(GlyphletInfo),           3);
    CreateSRV(g_textBuf.Get(),     (UINT)textLayout.size(),            sizeof(CharacterRenderInfo),    4);

    // Compute bounds for an initial "fit" projection.
    float minX =  1e30f, maxX = -1e30f;
    float minY =  1e30f, maxY = -1e30f;
    for (const auto& ci : textLayout) {
        int cp = (int)ci.character;
        Glyphlet gl = fontProc.processGlyph(cp);
        for (const auto& v : gl.vertices) {
            float wx = v[0] + ci.posX;
            float wy = v[1] + ci.posY;
            if (wx < minX) minX = wx;
            if (wx > maxX) maxX = wx;
            if (wy < minY) minY = wy;
            if (wy > maxY) maxY = wy;
        }
    }

    if (!(minX < maxX) || !(minY < maxY)) {
        strcpy_s(g_lastTextError, "Failed to compute bounds for this text.");
        return false;
    }

    float w = (maxX - minX);
    float h = (maxY - minY);
    float padX = (w > 0.0f) ? (w * 0.05f) : 10.0f;
    float padY = (h > 0.0f) ? (h * 0.15f) : 10.0f;

    // Update base view (used for camera fit) and reset camera.
    g_baseView.left   = minX - padX;
    g_baseView.right  = maxX + padX;
    g_baseView.bottom = minY - padY;
    g_baseView.top    = maxY + padY;
    g_camera.Reset();

    float4x4 proj = g_camera.BuildOrthoMatrixForViewport(g_baseView, (float)g_backbufferW, (float)g_backbufferH);
    memcpy(g_constantBufPtr, &proj, sizeof(proj));

    return true;
}

static bool TryApplyFont(FontProcessor& fontProc, const std::filesystem::path& newFontPath)
{
    g_lastFontError[0] = '\0';

    FontProcessor tmp;
    if (!tmp.loadFont(newFontPath, FONT_SIZE)) {
        const std::string p = newFontPath.u8string();
        sprintf_s(g_lastFontError, "Failed to load font: %s", p.c_str());
        return false;
    }

    if (!RebuildTextResources(tmp, g_renderText)) {
        if (g_lastTextError[0]) {
            sprintf_s(g_lastFontError, "Font loaded, but rebuild failed: %s", g_lastTextError);
        } else {
            strcpy_s(g_lastFontError, "Font loaded, but rebuild failed.");
        }
        return false;
    }

    fontProc = std::move(tmp);
    g_fontPath = newFontPath;
    SyncSystemFontIndexToCurrentPath();
    return true;
}

static void UpdateTransformMatrixFromCamera()
{
    if (!g_constantBufPtr)
        return;

    const float4x4 proj = g_camera.BuildOrthoMatrixForViewport(g_baseView, (float)g_backbufferW, (float)g_backbufferH);
    memcpy(g_constantBufPtr, &proj, sizeof(proj));
}

// ---------------------------------------------------------------------------
// Wait for GPU to finish current frame
// ---------------------------------------------------------------------------
static void WaitForFrame()
{
    const UINT64 fv = ++g_fenceValue;
    ThrowIfFailed(g_cmdQueue->Signal(g_fence.Get(), fv), "Signal fence (frame)");
    g_fenceValues[g_frameIndex] = fv;
    if (g_fence->GetCompletedValue() < fv) {
        ThrowIfFailed(g_fence->SetEventOnCompletion(fv, g_fenceEvent), "SetEventOnCompletion (frame)");
        WaitForSingleObject(g_fenceEvent, INFINITE);
    }
}

// ---------------------------------------------------------------------------
// Resize swapchain + RTVs (called from main loop when WM_SIZE is received)
// ---------------------------------------------------------------------------
static void ResizeSwapChain(UINT newW, UINT newH)
{
    if (!g_swapChain || !g_device || !g_rtvHeap)
        return;
    if (newW == 0 || newH == 0)
        return;
    if (newW == g_backbufferW && newH == g_backbufferH)
        return;

    // Make sure the GPU is not using the current backbuffers.
    WaitForFrame();

    for (UINT i = 0; i < FRAME_COUNT; ++i) {
        g_renderTargets[i].Reset();
    }

    DXGI_SWAP_CHAIN_DESC scDesc = {};
    ThrowIfFailed(g_swapChain->GetDesc(&scDesc), "SwapChain GetDesc");

    ThrowIfFailed(g_swapChain->ResizeBuffers(
        FRAME_COUNT, newW, newH, scDesc.BufferDesc.Format, scDesc.Flags),
        "SwapChain ResizeBuffers");

    g_frameIndex = g_swapChain->GetCurrentBackBufferIndex();
    g_backbufferW = newW;
    g_backbufferH = newH;

    // Recreate RTVs for the new backbuffers.
    D3D12_CPU_DESCRIPTOR_HANDLE rtvHandle = g_rtvHeap->GetCPUDescriptorHandleForHeapStart();
    for (UINT i = 0; i < FRAME_COUNT; ++i) {
        ThrowIfFailed(g_swapChain->GetBuffer(i, IID_PPV_ARGS(&g_renderTargets[i])),
                      "GetBuffer (resize)");
        g_device->CreateRenderTargetView(g_renderTargets[i].Get(), nullptr, rtvHandle);
        rtvHandle.ptr += g_rtvDescSize;
    }
}

// ---------------------------------------------------------------------------
// Render one frame
// ---------------------------------------------------------------------------
static void RenderFrame()
{
    auto* alloc = g_cmdAlloc[g_frameIndex].Get();
    ThrowIfFailed(alloc->Reset(), "Reset alloc");
    ThrowIfFailed(g_cmdList->Reset(alloc, g_pso.Get()), "Reset cmdList");

    // Transition render target to RENDER_TARGET
    D3D12_RESOURCE_BARRIER barrier = {};
    barrier.Type                   = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
    barrier.Transition.pResource   = g_renderTargets[g_frameIndex].Get();
    barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_PRESENT;
    barrier.Transition.StateAfter  = D3D12_RESOURCE_STATE_RENDER_TARGET;
    barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
    g_cmdList->ResourceBarrier(1, &barrier);

    // Set render target
    D3D12_CPU_DESCRIPTOR_HANDLE rtvHandle = g_rtvHeap->GetCPUDescriptorHandleForHeapStart();
    rtvHandle.ptr += g_frameIndex * g_rtvDescSize;
    g_cmdList->OMSetRenderTargets(1, &rtvHandle, FALSE, nullptr);

    // Clear to dark background
    float clearColor[4] = { 0.1f, 0.1f, 0.15f, 1.0f };
    g_cmdList->ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);

    // Set viewport and scissor
    D3D12_VIEWPORT viewport = { 0.0f, 0.0f, (float)g_backbufferW, (float)g_backbufferH, 0.0f, 1.0f };
    D3D12_RECT scissor = { 0, 0, (LONG)g_backbufferW, (LONG)g_backbufferH };
    g_cmdList->RSSetViewports(1, &viewport);
    g_cmdList->RSSetScissorRects(1, &scissor);

    // Set root signature and descriptor heap
    g_cmdList->SetGraphicsRootSignature(g_rootSig.Get());
    ID3D12DescriptorHeap* heaps[] = { g_srvHeap.Get() };
    g_cmdList->SetDescriptorHeaps(1, heaps);

    // Root parameter 0: CBV (constant buffer)
    g_cmdList->SetGraphicsRootConstantBufferView(0, g_constantBuf->GetGPUVirtualAddress());

    // Root parameter 1: SRV descriptor table
    g_cmdList->SetGraphicsRootDescriptorTable(1, g_srvHeap->GetGPUDescriptorHandleForHeapStart());

    // Dispatch mesh shader: one thread group per character
    if (g_numCharacters > 0) {
        g_cmdList->DispatchMesh(g_numCharacters, 1, 1);
    }

    // Render Dear ImGui on top (while still in RENDER_TARGET state)
    if (g_imguiInitialized) {
        ID3D12DescriptorHeap* heapsImgui[] = { g_imguiSrvHeap.Get() };
        g_cmdList->SetDescriptorHeaps(1, heapsImgui);
        ImGui_ImplDX12_RenderDrawData(ImGui::GetDrawData(), g_cmdList.Get());
    }

    // Transition render target to PRESENT
    barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
    barrier.Transition.StateAfter  = D3D12_RESOURCE_STATE_PRESENT;
    g_cmdList->ResourceBarrier(1, &barrier);

    ThrowIfFailed(g_cmdList->Close(), "Close cmdList");

    ID3D12CommandList* lists[] = { g_cmdList.Get() };
    g_cmdQueue->ExecuteCommandLists(1, lists);

    g_swapChain->Present(1, 0);

    WaitForFrame();
    g_frameIndex = g_swapChain->GetCurrentBackBufferIndex();
}

// ---------------------------------------------------------------------------
// Cleanup
// ---------------------------------------------------------------------------
static void Cleanup()
{
    // Wait for all frames
    for (UINT i = 0; i < FRAME_COUNT; ++i) {
        g_frameIndex = i;
        WaitForFrame();
    }

    ShutdownImGui();

    if (g_fenceEvent) CloseHandle(g_fenceEvent);
    if (g_constantBufPtr) {
        g_constantBuf->Unmap(0, nullptr);
        g_constantBufPtr = nullptr;
    }
}

// ---------------------------------------------------------------------------
// Window procedure
// ---------------------------------------------------------------------------
static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    // Let Dear ImGui consume inputs first.
    if (g_imguiInitialized) {
        if (ImGui_ImplWin32_WndProcHandler(hwnd, msg, wp, lp))
            return 1;
    }

    static bool s_isPanning = false;
    static int  s_lastMouseX = 0;
    static int  s_lastMouseY = 0;

    switch (msg) {
    case WM_DESTROY:
        g_running = false;
        PostQuitMessage(0);
        return 0;
    case WM_SIZE:
        if (wp == SIZE_MINIMIZED) {
            g_isMinimized = true;
            g_backbufferW = 0;
            g_backbufferH = 0;
            return 0;
        }
        g_isMinimized = false;
        g_pendingResizeW = (UINT)LOWORD(lp);
        g_pendingResizeH = (UINT)HIWORD(lp);
        g_pendingResize = true;
        return 0;
    case WM_KEYDOWN:
        if (wp == VK_ESCAPE) {
            g_running = false;
            DestroyWindow(hwnd);
        }
        return 0;
    case WM_LBUTTONDOWN:
        if (g_imguiInitialized && ImGui::GetIO().WantCaptureMouse)
            return 0;
        s_isPanning = true;
        s_lastMouseX = GET_X_LPARAM(lp);
        s_lastMouseY = GET_Y_LPARAM(lp);
        SetCapture(hwnd);
        return 0;
    case WM_LBUTTONUP:
        if (s_isPanning) {
            s_isPanning = false;
            ReleaseCapture();
        }
        return 0;
    case WM_MOUSEMOVE:
        if (s_isPanning) {
            const int x = GET_X_LPARAM(lp);
            const int y = GET_Y_LPARAM(lp);
            const int dx = x - s_lastMouseX;
            const int dy = y - s_lastMouseY;
            s_lastMouseX = x;
            s_lastMouseY = y;

            RECT rc = {};
            GetClientRect(hwnd, &rc);
            const float vw = (float)(rc.right - rc.left);
            const float vh = (float)(rc.bottom - rc.top);
            g_camera.PanByPixels((float)dx, (float)dy, vw, vh, g_baseView);
            return 0;
        }
        break;
    case WM_MOUSEWHEEL:
        if (g_imguiInitialized && ImGui::GetIO().WantCaptureMouse)
            return 0;
        {
            const int delta = GET_WHEEL_DELTA_WPARAM(wp);

            POINT pt = { GET_X_LPARAM(lp), GET_Y_LPARAM(lp) }; // screen coords
            ScreenToClient(hwnd, &pt);

            RECT rc = {};
            GetClientRect(hwnd, &rc);
            const float vw = (float)(rc.right - rc.left);
            const float vh = (float)(rc.bottom - rc.top);

            g_camera.ZoomAtCursor((float)delta, (float)pt.x, (float)pt.y, vw, vh, g_baseView);
        }
        return 0;
    }
    return DefWindowProcW(hwnd, msg, wp, lp);
}

// ---------------------------------------------------------------------------
// Entry point
// ---------------------------------------------------------------------------
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow)
{
    // Register window class
    WNDCLASSEXW wc = {};
    wc.cbSize        = sizeof(wc);
    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc   = WndProc;
    wc.hInstance     = hInstance;
    wc.hCursor       = LoadCursorW(nullptr, (LPCWSTR)IDC_ARROW);
    wc.lpszClassName = L"MeshShaderFontWnd";
    RegisterClassExW(&wc);

    // Create window
    RECT r = { 0, 0, WINDOW_W, WINDOW_H };
    AdjustWindowRect(&r, WS_OVERLAPPEDWINDOW, FALSE);
    g_hwnd = CreateWindowExW(
        0, L"MeshShaderFontWnd", WINDOW_TITLE,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT,
        r.right - r.left, r.bottom - r.top,
        nullptr, nullptr, hInstance, nullptr);

    ShowWindow(g_hwnd, nCmdShow);
    UpdateWindow(g_hwnd);

    try {
        // Initialize D3D12
        InitD3D12();

        // Create pipeline state
        CreatePipelineState();

        // Initialize ImGui
        InitImGui();

        // Populate system font list for UI.
        RefreshSystemFontList();

        // Load font and process glyphs
        FontProcessor fontProc;
        if (!fontProc.loadFont(g_fontPath, FONT_SIZE)) {
            char errMsg[256];
            const std::string p = g_fontPath.u8string();
            sprintf_s(errMsg, "Failed to load font: %s", p.c_str());
            MessageBoxA(nullptr, errMsg, "Error", MB_OK | MB_ICONERROR);
            return 1;
        }

        // Upload font data to GPU
        if (!RebuildTextResources(fontProc, g_renderText)) {
            MessageBoxA(nullptr, g_lastTextError[0] ? g_lastTextError : "Text rebuild failed.",
                        "Error", MB_OK | MB_ICONERROR);
            return 1;
        }

        // Main loop
        MSG msg = {};
        while (g_running) {
            while (PeekMessageW(&msg, nullptr, 0, 0, PM_REMOVE)) {
                TranslateMessage(&msg);
                DispatchMessageW(&msg);
            }
            if (!g_running) break;

            // Apply pending resize (swapchain/backbuffer) before building UI / rendering.
            if (g_pendingResize) {
                g_pendingResize = false;
                if (!g_isMinimized && g_pendingResizeW > 0 && g_pendingResizeH > 0) {
                    ResizeSwapChain(g_pendingResizeW, g_pendingResizeH);
                }
            }

            if (g_isMinimized || g_backbufferW == 0 || g_backbufferH == 0) {
                Sleep(16);
                continue;
            }

            // Start ImGui frame + UI
            if (g_imguiInitialized) {
                ImGui_ImplDX12_NewFrame();
                ImGui_ImplWin32_NewFrame();
                ImGui::NewFrame();

                ImGui::Begin("Debug");
                ImGui::InputText("Text", g_textInput, (int)sizeof(g_textInput));

                if (ImGui::Button("Apply/Rebuild")) {
                    const std::string requested = g_textInput;
                    if (RebuildTextResources(fontProc, requested)) {
                        g_renderText = requested;
                    }
                }
                ImGui::SameLine();
                if (ImGui::Button("Reset view")) {
                    g_camera.Reset();
                }

                ImGui::Separator();
                ImGui::Text("Font");

                std::string fontPreview = g_fontPath.filename().u8string();
                if (g_systemFontIndex >= 0 && g_systemFontIndex < (int)g_systemFonts.size()) {
                    fontPreview = g_systemFonts[g_systemFontIndex].labelUtf8;
                }

                if (ImGui::BeginCombo("System font", fontPreview.c_str())) {
                    for (int i = 0; i < (int)g_systemFonts.size(); ++i) {
                        ImGui::PushID(i);
                        const bool isSelected = (i == g_systemFontIndex);
                        if (ImGui::Selectable(g_systemFonts[i].labelUtf8.c_str(), isSelected)) {
                            TryApplyFont(fontProc, g_systemFonts[i].path);
                        }
                        if (ImGui::IsItemHovered() && !g_systemFonts[i].fullPathUtf8.empty()) {
                            ImGui::SetTooltip("%s", g_systemFonts[i].fullPathUtf8.c_str());
                        }
                        if (isSelected) {
                            ImGui::SetItemDefaultFocus();
                        }
                        ImGui::PopID();
                    }
                    ImGui::EndCombo();
                }
                ImGui::SameLine();
                if (ImGui::Button("Browse...")) {
                    std::filesystem::path chosen;
                    if (OpenFontFileDialog(chosen)) {
                        TryApplyFont(fontProc, chosen);
                    }
                }
                ImGui::SameLine();
                if (ImGui::Button("Refresh list")) {
                    RefreshSystemFontList();
                }

                ImGui::TextWrapped("Font path: %s", g_fontPath.u8string().c_str());
                if (g_lastFontError[0]) {
                    ImGui::TextColored(ImVec4(1, 0.6f, 0.2f, 1), "Font: %s", g_lastFontError);
                }

                ImGui::Text("Active text: %s", g_renderText.c_str());
                ImGui::Text("Characters: %u", g_numCharacters);
                ImGui::Text("Camera: zoom=%.3f pan=(%.2f, %.2f)", g_camera.zoom(), g_camera.panX(), g_camera.panY());

                if (g_lastTextError[0]) {
                    ImGui::TextColored(ImVec4(1, 0.3f, 0.3f, 1), "Error: %s", g_lastTextError);
                }

                ImGui::End();
                ImGui::Render();
            }

            // Update constant buffer with current camera transform.
            UpdateTransformMatrixFromCamera();

            RenderFrame();
        }

        Cleanup();
    }
    catch (const std::exception& e) {
        MessageBoxA(nullptr, e.what(), "Fatal Error", MB_OK | MB_ICONERROR);
        return 1;
    }

    return 0;
}
